// Review Publisher - Phase 7, Step 11: Format and Post to GitHub
// Creates a single, well-structured comment on the PR

import { Octokit } from "@octokit/rest";
import { CategoryComment } from "@/types";

export type ReviewOutput = {
  architecture: {
    comments: CategoryComment[];
    overallAssessment: string;
  };
  security: {
    comments: CategoryComment[];
    overallAssessment: string;
  };
  maintainability: {
    comments: CategoryComment[];
    overallAssessment: string;
  };
};

export type ReviewMetadata = {
  filesAnalyzed: number;
  tokensUsed: number;
  reviewTime: number;
};

/**
 * Format review as GitHub markdown comment
 * Single comment, well-structured, professional
 */
export function formatReviewComment(
  review: ReviewOutput,
  metadata: ReviewMetadata
): string {
  const sections: string[] = [];

  // Header
  sections.push("## ðŸ¤– AI Code Review");
  sections.push("");
  sections.push(
    `*Analyzed ${metadata.filesAnalyzed} files in ${(
      metadata.reviewTime / 1000
    ).toFixed(1)}s*`
  );
  sections.push("");
  sections.push("---");
  sections.push("");

  // Count total issues by severity
  const allComments = [
    ...review.architecture.comments,
    ...review.security.comments,
    ...review.maintainability.comments,
  ];

  const severityCounts = {
    critical: allComments.filter((c) => c.severity === "critical").length,
    warning: allComments.filter((c) => c.severity === "warning").length,
    info: allComments.filter((c) => c.severity === "info").length,
  };

  // Summary
  if (allComments.length === 0) {
    sections.push("### âœ… No Issues Found");
    sections.push("");
    sections.push("The code looks good! No significant issues detected.");
  } else {
    sections.push("### ðŸ“Š Summary");
    sections.push("");
    sections.push("| Severity | Count |");
    sections.push("|----------|-------|");
    if (severityCounts.critical > 0) {
      sections.push(`| ðŸ”´ Critical | ${severityCounts.critical} |`);
    }
    if (severityCounts.warning > 0) {
      sections.push(`| ðŸŸ¡ Warning | ${severityCounts.warning} |`);
    }
    if (severityCounts.info > 0) {
      sections.push(`| ðŸ”µ Info | ${severityCounts.info} |`);
    }
  }

  sections.push("");
  sections.push("---");
  sections.push("");

  // Architecture Section
  if (review.architecture.comments.length > 0) {
    sections.push("### ðŸ—ï¸ Architecture");
    sections.push("");
    sections.push(formatCategoryComments(review.architecture.comments));
    sections.push("");
  } else {
    sections.push("### ðŸ—ï¸ Architecture");
    sections.push("");
    sections.push("âœ… No architectural concerns found.");
    sections.push("");
  }

  sections.push("---");
  sections.push("");

  // Security Section
  if (review.security.comments.length > 0) {
    sections.push("### ðŸ” Security");
    sections.push("");
    sections.push(formatCategoryComments(review.security.comments));
    sections.push("");
  } else {
    sections.push("### ðŸ” Security");
    sections.push("");
    sections.push("âœ… No security issues found.");
    sections.push("");
  }

  sections.push("---");
  sections.push("");

  // Maintainability Section
  if (review.maintainability.comments.length > 0) {
    sections.push("### ðŸ§¹ Maintainability");
    sections.push("");
    sections.push(formatCategoryComments(review.maintainability.comments));
    sections.push("");
  } else {
    sections.push("### ðŸ§¹ Maintainability");
    sections.push("");
    sections.push("âœ… Code is well-structured and maintainable.");
    sections.push("");
  }

  // Footer
  sections.push("---");
  sections.push("");
  sections.push("<sub>");
  sections.push(
    `Generated by AI PR Reviewer â€¢ ${metadata.tokensUsed.toLocaleString()} tokens used`
  );
  sections.push("</sub>");

  return sections.join("\n");
}

/**
 * Format comments for a single category
 */
function formatCategoryComments(comments: CategoryComment[]): string {
  const sections: string[] = [];

  // Group comments by file
  const byFile = new Map<string, CategoryComment[]>();
  for (const comment of comments) {
    if (!byFile.has(comment.file_path)) {
      byFile.set(comment.file_path, []);
    }
    byFile.get(comment.file_path)!.push(comment);
  }

  // Format each file's comments
  for (const [filePath, fileComments] of byFile) {
    sections.push(`**\`${filePath}\`**`);
    sections.push("");

    // Sort by severity (critical > warning > info) then by line number
    const sorted = fileComments.sort((a, b) => {
      const severityOrder = { critical: 0, warning: 1, info: 2 };
      const severityDiff =
        severityOrder[a.severity] - severityOrder[b.severity];
      if (severityDiff !== 0) return severityDiff;
      return a.line_start - b.line_start;
    });

    for (const comment of sorted) {
      const icon = getSeverityIcon(comment.severity);
      const lineRef =
        comment.line_start === comment.line_end
          ? `L${comment.line_start}`
          : `L${comment.line_start}-L${comment.line_end}`;

      sections.push(`${icon} **${lineRef}** â€” ${comment.message}`);
      sections.push("");
    }
  }

  return sections.join("\n");
}

/**
 * Get emoji icon for severity level
 */
function getSeverityIcon(severity: "critical" | "warning" | "info"): string {
  switch (severity) {
    case "critical":
      return "ðŸ”´";
    case "warning":
      return "ðŸŸ¡";
    case "info":
      return "ðŸ”µ";
  }
}

/**
 * Post formatted review to GitHub PR
 * Returns the comment ID
 */
export async function formatAndPostReview(
  octokit: Octokit,
  owner: string,
  repo: string,
  prNumber: number,
  review: ReviewOutput,
  metadata: ReviewMetadata
): Promise<number> {
  const body = formatReviewComment(review, metadata);

  try {
    // Post as issue comment (not a review comment)
    // This allows a single comment instead of per-line comments
    const { data: comment } = await octokit.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body,
    });

    return comment.id;
  } catch (error) {
    console.error("Error posting review to GitHub:", error);
    throw new Error(`Failed to post review: ${error}`);
  }
}

/**
 * Update an existing review comment
 * Useful if we want to re-review after new commits
 */
export async function updateReviewComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  commentId: number,
  review: ReviewOutput,
  metadata: ReviewMetadata
): Promise<void> {
  const body = formatReviewComment(review, metadata);

  try {
    await octokit.issues.updateComment({
      owner,
      repo,
      comment_id: commentId,
      body,
    });
  } catch (error) {
    console.error("Error updating review comment:", error);
    throw new Error(`Failed to update review: ${error}`);
  }
}

/**
 * Delete a review comment
 * Useful for testing or if we need to remove a bad review
 */
export async function deleteReviewComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  commentId: number
): Promise<void> {
  try {
    await octokit.issues.deleteComment({
      owner,
      repo,
      comment_id: commentId,
    });
  } catch (error) {
    console.error("Error deleting review comment:", error);
    throw new Error(`Failed to delete review: ${error}`);
  }
}

/**
 * Generate a preview of the review (for testing)
 * Returns formatted markdown without posting
 */
export function previewReview(
  review: ReviewOutput,
  metadata: ReviewMetadata
): void {
  const formatted = formatReviewComment(review, metadata);

  console.log("\n" + "=".repeat(80));
  console.log("REVIEW PREVIEW");
  console.log("=".repeat(80) + "\n");
  console.log(formatted);
  console.log("\n" + "=".repeat(80));
  console.log(`Length: ${formatted.length} characters`);
  console.log("=".repeat(80) + "\n");
}
